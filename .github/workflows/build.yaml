name: Build

concurrency:
  # Group by workflow, branch and PR number.
  # If the event is a merge group, use the merge group id as the PR number.
  # If it's not a PR or merge group, use 'main' as the PR number.
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event.pull_request.number || github.event.merge_group.id || 'main' }}
  # Cancel only in-progress jobs when it's a PR.
  cancel-in-progress: ${{ github.event_name == 'pull_request_target' || github.event_name == 'merge_group' }}

on:
  push:
    branches:
      - main
  pull_request_target:
    branches:
      - main

jobs:
  # Configure the commit SHA to use.
  configure:
    name: Configure
    runs-on: ubuntu-22.04
    timeout-minutes: 2
    outputs:
      commit-sha: ${{ env.COMMIT_SHA }}
    steps:
      - name: Evaluate commit
        run: |
          if [[ "${{ github.event_name }}" == "pull_request_target" ]]; then
              echo "PR is #${{ github.event.number }}..."
              echo "PR Head SHA is ${{ github.event.pull_request.head.sha }}..."
              echo "COMMIT_SHA=${{ github.event.pull_request.head.sha }}" >> $GITHUB_ENV
          else
              echo "Head SHA is ${{ github.sha }}..."
              echo "COMMIT_SHA=${{ github.sha }}" >> $GITHUB_ENV
          fi

  # Build and checks are unified into one job. This is because the build
  # needs to be done before the checks, as the checks will use the built
  # packages.
  check_build:
    name: Check & Build
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    needs:
      - configure
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.configure.outputs.commit-sha }}
      - name: Setup Node
        uses: abinnovision/actions@setup-node-dev
      - name: Install dependencies
        run: yarn install --immutable
      - name: Check (lint & format)
        run: yarn check
      - name: Build
        run: yarn build
      - name: Check Dependencies
        run: |
          yarn dedupe --check || (echo "yarn.lock is not up to date, run 'yarn dedupe'" && exit 1)
          yarn turbo boundaries || (echo "turbo boundaries failed" && exit 1)

  # Will check if the release is needed and create a release PR if so.
  release:
    name: Release
    needs:
      - configure
      - check_build
    uses: abinnovision/workflows/.github/workflows/release-v2.yaml@main
    secrets: inherit
    # Only run on push to "main" branch.
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

  publish:
    name: Publish
    runs-on: ubuntu-latest
    needs:
      - configure
      - release
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: "write"
      id-token: "write"
    steps:
      - id: gh-app-token
        name: "Generate GitHub App Token"
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_RELASER_CUSTOM_ID }}
          private-key: ${{ secrets.APP_RELASER_CUSTOM_PK }}
          permission-contents: "write"
          permission-issues: "write"
          permission-pull-requests: "write"
          permission-workflows: "write"
      - id: gh-app-details
        name: "Get GitHub App Details"
        env:
          GH_TOKEN: ${{ steps.gh-app-token.outputs.token }}
        shell: bash
        run: |
          # Fetch the id of the bot user.
          response=$(gh api "/users/${{ steps.gh-app-token.outputs.app-slug }}[bot]") >> "$GITHUB_OUTPUT"

          # Extract the id of the bot user.
          user_id=$(echo "$response" | jq -cr ".id")

          echo "committer-email=${{ steps.gh-app-token.outputs.app-slug }}[bot] <$user_id+${{ steps.gh-app-token.outputs.app-slug }}[bot]@users.noreply.github.com>" >> "$GITHUB_OUTPUT"
          echo "committer-name=${{ steps.gh-app-token.outputs.app-slug }}[bot]" >> "$GITHUB_OUTPUT"
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.configure.outputs.commit-sha }}
          token: ${{ steps.gh-app-token.outputs.token }}
      - name: Setup Node
        uses: abinnovision/actions@setup-node-dev
      - name: Install dependencies
        run: yarn install --immutable
      - name: Build
        run: yarn run build
      - name: Publish
        shell: bash
        run: |
          set -euo pipefail

          git config --global user.name "${{ steps.gh-app-details.outputs.committer-name }}"
          git config --global user.email "${{ steps.gh-app-details.outputs.committer-email }}"

          # Unified function to publish both actions and workflows
          publish_item() {
            local path=$1
            local mode=$2  # "dev" or "release"

            cd ${{ github.workspace }}

            echo "Publishing '$path' ($mode mode)..."

            # Detect type and set type-specific variables
            local item_type
            local item_name
            local commit_prefix
            local staging_dir

            # Define item type, name, and other variables based on path
            if [[ "$path" == *"actions/"* ]]; then
              item_type="action"
              item_name=$(jq -r '.name' "$path/package.json")
              commit_prefix=""
              staging_dir="/opt/temporary/action-$item_name"
            else
              item_type="workflow"
              item_name=$(jq -r '.name' "$path/package.json")
              commit_prefix="workflow "
              staging_dir="/opt/temporary/workflow-$item_name"
            fi

            # Validate item name
            if [[ -z "$item_name" || "$item_name" == "null" ]]; then
              echo "Error: Invalid or missing 'name' in $path/package.json"
              exit 1
            fi

            local item_version=$(jq -r '.version' "$path/package.json")

            # Validate item version
            if [[ -z "$item_version" || "$item_version" == "null" ]]; then
              echo "Error: Invalid or missing 'version' in $path/package.json"
              exit 1
            fi

            # Pack the package
            yarn --cwd "$path" pack

            # Create staging environment
            mkdir -p "$staging_dir"
            mv "$path/package.tgz" "$staging_dir/package.tgz"

            cd "$staging_dir"

            # Unpack and clean up
            tar --strip-components=1 -xzf package.tgz && rm package.tgz

            # Workflow-specific: restructure files and move the workflow file
            if [[ "$item_type" == "workflow" ]]; then
              mkdir -p .github/workflows
              mv workflow.yaml .github/workflows/workflow.yaml
            fi

            # Determine branch name and version based on mode
            local branch_name
            local version_tag

            if [[ "$mode" == "dev" ]]; then
              branch_name="$item_type/$item_name/dev"
              version_tag="dev"
            else
              branch_name="$item_type/$item_name/v$item_version"
              version_tag="$item_version"
            fi

            # Create git repository
            git init -b "$branch_name"
            git remote add origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/$GITHUB_REPOSITORY

            # Commit all files
            git add .
            git commit -m "chore: release ${commit_prefix}${item_name}@${version_tag}"

            # Fetch existing tags
            git fetch origin --tags -f

            dist_sha=$(git rev-list -n 1 HEAD)

            # Create and collect tags based on mode
            # Tag format is consistent for both actions and workflows: name-v{version}
            local tags_to_push=()

            if [[ "$mode" == "dev" ]]; then
              # Dev tags: name-dev
              git tag -f "${item_name}-dev" "$dist_sha"
              tags_to_push+=("${item_name}-dev")
            else
              # Release tags: name-v{version} (patch, minor, major)
              git tag -f "${item_name}-v${item_version}" "$dist_sha"
              git tag -f "${item_name}-v$(echo $item_version | cut -d. -f1-2)" "$dist_sha"
              git tag -f "${item_name}-v$(echo $item_version | cut -d. -f1)" "$dist_sha"

              tags_to_push+=("${item_name}-v${item_version}")
              tags_to_push+=("${item_name}-v$(echo $item_version | cut -d. -f1-2)")
              tags_to_push+=("${item_name}-v$(echo $item_version | cut -d. -f1)")
            fi

            # Push branch
            git push --force origin "$branch_name"

            # Push only the specific tags we created
            for tag in "${tags_to_push[@]}"; do
              git push --force origin "refs/tags/$tag"
            done

            # Cleanup: return to workspace and remove staging directory
            cd ${{ github.workspace }}
            rm -rf "$staging_dir"
          }

          # Phase 1: Publish releases (if any were created)
          if [[ "${{ needs.release.outputs.releases-created }}" == "true" ]]; then
            echo "==> Publishing versioned releases..."
            echo '${{ needs.release.outputs.paths-released }}' | jq -cr '.[]' | while read path; do
              publish_item "$path" "release"
            done
          else
            echo "==> No releases created, skipping versioned publishing"
          fi

          # Phase 2: Always publish dev builds
          echo "==> Publishing dev builds..."

          # Get the list of all workspaces
          workspace_output=$(yarn workspaces list --json)

          all_locations=()
          while read -r raw; do
            location=$(echo "$raw" | jq -r '.location')

            # Include both actions and workflows
            if [[ "$location" == *"actions/"* ]] || [[ "$location" == *"workflows/"* ]]; then
              all_locations+=("$location")
            fi
          done <<< "$workspace_output"

          # Publish all items as dev builds
          for path in "${all_locations[@]}"; do
            publish_item "$path" "dev"
          done
